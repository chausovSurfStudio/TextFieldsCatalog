# Возможности полей ввода

## Содержание

- [Существующие типы полей](#Существующие-типы-полей)
- [Доступные методы](#Доступные-методы)
- [Замыкания](#Замыкания)
- [HeightLayoutPolicy](#HeightLayoutPolicy)
- [ValidationPolicy](#ValidationPolicy)
- [TextFieldMode](#TextFieldMode)
- [Кастомные клавиатуры и переключение полей](#Кастомные-клавиатуры-и-переключение-полей)
	- [DatePickerView](#DatePickerView)
	- [PlainPickerView](#PlainPickerView)
	- [Переключение полей ввода](#Переключение-полей-ввода)
- [Валидаторы](#Валидаторы)
	- [TextFieldValidation](#TextFieldValidation)
	- [TextFieldValidator](#TextFieldValidator)
	- [Локализация TextFieldValidator](#Локализация-TextFieldValidator)
- [Форматтеры](#Форматтеры)
- [Особенности UnderlinedTextView](##Особенности-UnderlinedTextView)
- [Побочные фичи](#Побочные-фичи)
	- [InnerTextField](#InnerTextField)
	- [MaskTextFieldFormatter](#MaskTextFieldFormatter)
- [Кастомизация](#Кастомизация)
- [Заметки разработчика](#Заметки-разработчика)

## Существующие типы полей

Все поля выполнены по одному принципу - это UIView, некая обертка над UITextField/UITextView, где помимо полей содержатся другие элементы, как UILabel с подсказками/ошибками, плейсхолдеры, кнопки, а доступ к самим полям ввода напрямую извне закрыт.

На данный момент в проекте имеются следующие виды полей ввода:

### UnderlinedTextField
<p align="center">
	<img src="https://raw.githubusercontent.com/chausovSurfStudio/TextFieldsCatalog/master/tech_docs/Images/UnderlinedTextField.png" />
</p>

Отличительными особенностями данного поля являются:

* возможность показа под полем ввода подчеркивающей линии (или вы можете скрыть ее)
* возможность изменения типа плейсхолдера (может быть плавающим, статичным или имитировать поведение статичного плейсхолдера)

### UnderlinedTextView
<p align="center">
	<img src="https://raw.githubusercontent.com/chausovSurfStudio/TextFieldsCatalog/master/tech_docs/Images/UnderlinedTextView.png" />
</p>

Данное поле - обертка над UITextView, а не над UITextField, как предыдущие. Область применения - поля ввода, где ожидается наличие большого количества текста, который пользователь должен видеть полностью, потому поле при увеличении количества текста растягивается в высоту.

## Доступные методы

Данная секция содержит описания методов и область их применения, которые доступны в большинстве полей ввода в данной библиотеке.

````swift
func setup(placeholderServices: [AbstractPlaceholderService])
func add(placeholderService service: AbstractPlaceholderService)
````

Позволяют установить/добавить сервисы, отвечающие за отрисовку плейсхолдеров (более подробно можно прочитать [здесь](https://github.com/chausovSurfStudio/TextFieldsCatalog/blob/master/tech_docs/Configuration.md))

````swift
// UITextField
func setup(layoutService: TextFieldLayoutServiceAbstract)

// UITextView
func setup(layoutService: TextViewLayoutServiceAbstract)
````

Подзволяет установить собвстенный сервис верстки (более подробно можно прочитать [здесь](https://github.com/chausovSurfStudio/TextFieldsCatalog/blob/master/tech_docs/Configuration.md))

````swift
func configure(placeholder: String?)
````

Метод позволяет установить плейхолдер.

**Важно**: плейсхолдер будет установлен в первый placeholder-service, либо никуда, если сервисов нет.

````swift
func configure(maxLength: Int?)
````
Метод позволяет ограничить максимальное число символов в поле. Пользователь физически не сможет ввести строку больше, чем `maxLength`.

**Важно**: при использования `MaskFormatter` поле `maxLength` становится бесполезным в силу того, что теряется возможность контроллировать число символов, введенных пользователем, из-за использования сторонней библиотеки для реализации форматтеров. Подробную информацию о данном механизме можно найти ниже.

````swift
func configure(heightConstraint: NSLayoutConstraint)
````
В полях ввода предусмотрены два режима работы - работа в рамках фиксированной высоты элемента и изменяемой (подробнее об этом можно прочитать ниже в рамках заметки о [HeightLayoutPolicy](#HeightLayoutPolicy)). В случае работы в режиме изменяемой высоты - поле будет менять свои размеры (а следственно и расположение своих внутренних элементов) в процессе работы. 

Чтобы при этом менялась высота и самого контейнера (которая обычно задается извне, при создании самого элемента в вашем проекте) - необходимо передать полю объект `NSLayoutConstraint` с помощью данного метода, значение которого будет управляться самим полем. 

Альтернативный способ - использовать замыкание `onHeightChanged`, в котором будет передаваться значение новой высоты элемента, чтобы обновить его самому.

````swift
func configure(correction: UITextAutocorrectionType?, keyboardType: UIKeyboardType?)
````
Метод позволяет установить `UITextAutocorrectionType` для поля ввода, а также тип клавиатуры. Можно передать nil, тогда параметр обновляться не будет.

````swift
func configure(autocapitalizationType: UITextAutocapitalizationType)
````
Метод позволяет установить `UITextAutocapitalizationType` для поля ввода. Может быть полезно, к примеру, для полей ввода ФИО, где каждое новое слово необходимо писать с новой буквы.

````swift
func configureContentType(_ contentType: UITextContentType)
````
Метод позволяет установить `UITextContentType` для поля ввода.

````swift
func configure(supportPlaceholder: String, configuration: NativePlaceholderConfiguration)
````
Метод позволяет установить "вспомогательный плейсхолдер". Подробнее о том, что это и зачем, можно почитать [здесь](https://github.com/chausovSurfStudio/TextFieldsCatalog/blob/master/tech_docs/Configuration.md).

````swift
func setText(_ text: String?)
````
В силу того, что доступ к UITextField напрямую закрыт - данный метод служит для установки текста в поле ввода.

````swift
func currentText() -> String?
````
А с помощью данного метода можно получить текущее значение, введенное в поле ввода.

````swift
func hideKeyboard()
````
Вызов данного метода приведет к сокрытию клавиатуры, в случае если поле ввода будет в фокусе (вместо клавиатуры покажется `ничего`). Может быть полезно в тех случаях, когда вместо показа клавиатуры необходимо сделать что-то другое (показать ячейку таблицы, к примеру).

````swift
func setTextFieldIdentifier(_ identifier: String)
````
В случае, если на вашем проекте есть практика написаний UI-тестов - данный метод позволит установить accessibilityIdentifiers к элементам поля ввода. Правила составления идентификаторов следующие: если передать в метод строку вида `phoneField`, то 
* на контейнер с полем ввода будет установлен идентификатор вида `phoneField`
* на UITextField/UITextView будет установлен идентификатор вида `phoneField_input`
* на кнопку в поле ввода - `phoneField_button`
* на лейбл с подсказкой - `phoneField_hint`

````swift
func setError(with errorMessage: String?, animated: Bool)
````
Метод позволяет установить ошибку в поле ввода, передав при необходимости некоторое сообщение, которое будет отображено в информационном лейбле.

````swift
func isValidState(forceValidate: Bool = false) -> Bool
````
Основной метод, с помощью которого можно произвести валидацию введенных значений в поле ввода. В процессе вызова - будет вызван метод, проводящий валидацию текста в поле ввода, будут обновлены все внутренние переменные, а UI обновится в соответствии с их состоянием. Параметр forceValidate позволяет провести валидацию даже в том случае, если в данный момент в поле ввода установлена ошибка, при передаче же `false` - валидация и обновление состояния произведены не будут, если поле уже в состоянии ошибки.

````swift
func reset()
````
Метод позволяет откатить поле ввода до девственного состояния, очистив текст и обновив все внутренние переменные.

````swift
func resetErrorState()
````
Данный же метод позволяет только сбросить состояние ошибки, может быть полезен в случае, когда необходимо сбросить ошибку, но сохранить текущий введенный текст.

````swift
func disablePasteAction()
````
Метод позволяет запретить вставку текста в поле ввода.

````swift
func disableTextField()
````
Метод позволяет сделать поле ввода неактивным.

````swift
func enableTextField()
````
Метод позволяет сделать поле ввода активным, готовым к взаимодействию с пользователем.

````swift
func isEnabled() -> Bool
````
Возвращает `true`, если в данный момент поле ввода готово к взаимодействию с пользователем, `false` в противном случае.

````swift
func setHint(_ hint: String)
````
Данный метод позволяет установить в информационный лейбл некоторый текст-подсказку, который будет отображаться пользователю, когда поле ввода в фокусе. Данное сообщение будет заменяться сообщением об ошибке в случае, если возникает ошибка и ей соответствует какой-либо текст.

````swift
func isCurrentFirstResponder() -> Bool
````
Возвращает `true`, если поле ввода находится в фокусе, `false` в противном случае.

````swift
func makeFirstResponder()
````
В силу того, что UITextField/UITextView напрямую закрыты от воздействия извне, то данный метод: единственная возможность сделать поле ввода активным (в фокусе) из кода.

````swift
func setReturnKeyType(_ type: UIReturnKeyType)
````
Метод позволяет установить UIReturnKeyType для поля ввода. (Метод **отсутствует** в UnderlinedTextView в силу того, что кнопка `return` в UITextView обычно служит для переноса строки)

## Замыкания

В процессе работы поля ввода возникает ряд событий, о которых может быть полезно знать извне. На все такие события прокинуты замыкания:

* ```var onBeginEditing: ((UnderlinedTextField) -> Void)?``` - вызвается в начале редактирования значения в поле ввода
* ```var onEndEditing: ((UnderlinedTextField) -> Void)?``` - после окончания редактирования
* ```var onTextChanged: ((UnderlinedTextField) -> Void)?``` - при смене текста в поле ввода
* ```var onShouldReturn: ((UnderlinedTextField) -> Void)?``` - в случае нажатия кнопки `return`
* ```var onActionButtonTap: ((UnderlinedTextField) -> Void)?``` - в случае нажатия кнопки внутри поля ввода
* ```var onValidateFail: ((UnderlinedTextField) -> Void)?``` - в случае, если введенное в поле ввода значение не прошло проверку
* ```var onHeightChanged: ((CGFloat) -> Void)?``` - при смене высоты элемента
* ```var onContainerStateChanged: ((FieldContainerState) -> Void)?``` - вызывается при смене состояния поля ввода

## HeightLayoutPolicy

При использовании полей ввода есть возможность выбрать из двух доступных вариантов режима работы с высотой поля:

* `.fixed` - поле ввода будет иметь фиксированную высоту, которую элемент имеет при создании
* `.flexible(CGFloat, CGFloat)` - высота будет изменяться в зависимости от наличия ошибки/подсказки/состояния поля ввода. При этом обязательно указать два значения: минимальную высоту поля ввода, а также минимальное расстояние от лейбла с подсказкой до нижней границы поля

## ValidationPolicy

В первых версиях полей валидация введенного текста согласно правилам валидатора происходила всегда при снятии фокуса. Теперь же появилась возможность управлять этим поведением, для чего предусмотрена `public` переменная `validationPolicy`.

Присутствуют четыре варианта поведения:

* `.always` - старый вариант, когда валидация текста будет происходить всегда при снятии фокуса
* `.notEmptyText` - валидация происходит только тогда, когда при снятии фокуса текст в поле ввода не пуст (если вы что-то ввели в поле, а потом стерли, а по правилам оно должно быть не пустое - ошибки не будет, так как введенный в поле текст - пуст)
* `.afterChanges` - валидация происходит после первого изменения текста в поле ввода (позволяет получить ошибку в предыдущем описанном варианте, то есть валидация происходит при снятии фокуса после первого взаимодействия с полем)
* `.never` - валидация никогда не выполняется (не знаю, зачем вам может понадобится такой вариант, но вдруг?)

## TextFieldMode

Поля ввода (кроме UnderlinedTextView) имеют возможность установки так называемого `мода`, которым регулируется наличие и поведение кастомной кнопки внутри поля:

* `.plain` - простое поле ввода без дополнительных кнопок
* `.password(TextFieldPasswordModeBehavior)` - в данном режиме поле ввода заточено под работу с паролем: кнопка принимает форму 'глазика', при нажатии на кнопку меняется свойство поля isSecureTextEntry (поведение, когда текст заменяется точками). С помощью значения `TextFieldPasswordModeBehavior` можно управлять поведением видимости этой кнопки. У enum'а три значения: если установить `.alwaysVisible` - кнопка будет видна всегда, если установить `.visibleOnNotEmptyText` - будет видна когда текст в поле ввода не пуст, при установке `visibleAfterFirstEntry` - кнопка появится после ввода хотя бы одного символа и больше никогда не скроется.
* `.custom(ActionButtonConfiguration)` - позволяет добавить к полю ввода любую кнопку на ваше усмотрение. Нажатие же на нее можно отловить с помощью замыкания `onActionButtonTap`

## Кастомные клавиатуры и переключение полей

Весьма распространенным кейсом является возможность выбора какой-либо даты, к примеру, даты рождения при регистрации на каком-либо сервисе, а также выбора какого-нибудь варианта из заранее определенного списка. Потому в библиотеке присутствуют два кастомных варианта клавиатуры - `DatePickerView` для выбора даты и `PlainPickerView` для выбора чего-либо из заранее определенного списка. Оба варианта клавиатуры кастомизируются под ваши нужды, подробнее об их использовании и кастомизации рассказано далее.

### DatePickerView

<p align="center">
	<img src="https://raw.githubusercontent.com/chausovSurfStudio/TextFieldsCatalog/master/tech_docs/Images/DatePickerView.png" />
</p>

Клавиатура представляет собой обертку над обычным UIDatePicker. В самом простом случае - вам будет достаточно выполнить следующие шаги:

````swift
textField.inputView = DatePickerView.view(size: inputViewSize,
                                          textField: textField)
````

* Создать клавиатуру нужного вам размера, при создании указав размер и поле ввода, к которому клавиатуры будет привязана
* Также при создании вы можете указать `dateFormat` - формат, в котором дата будет отображена в поле ввода. По-умолчанию она равна "dd.MM.yyyy"
* Присоединить клавиатуру к полю ввода, для этой цели служит такое свойство, как inputView (не забываем, что доступ к UITextField напрямую закрыт)

**Важно**: высота клавиатуры должна быть более 47 (это высота включенного в нее тулбара), в случае невыполнения этого требования - последует креш вашего приложения.

При изменении значения в барабане - дата будет автоматически устанавливаться в поле ввода в соответствии с форматом, указанным при создании клавиатуры. Получить же выбранное значение даты можно с помощью замыкания `var onDateChanged: ((Date) -> Void)?`

Помимо UIDatePicker клавиатура содержит верхний тулбар с кнопками переключения между полями ввода и кнопкой "Готово", который имеет возможность кастомизации.

Доступ к содержащемуся внутри клавиатуры UIDatePicker открыт, потому у вас есть возможность настроить его так, как вы считаете необходимым.

Более сложный вариант создания клавиатуры, включающий в себя кастомизацию, выглядит следующим образом:

````swift
import TextFieldsCatalog

private enum Constants {
    static let inputViewHeight: CGFloat = 261
}

extension DatePickerView {

    static func `default`(for textField: DateTextField) -> DatePickerView {
        let viewSize = CGSize(width: UIScreen.main.bounds.width,
                              height: Constants.inputViewHeight)
        let view = DatePickerView.view(size: viewSize, textField: textField)
        view.datePicker.backgroundColor = Color.TextField.Picker.background
        view.topViewConfiguration = PickerTopViewConfiguration.default()
        return view
    }

}

private extension PickerTopViewConfiguration {

    static func `default`() -> PickerTopViewConfiguration {
        let buttonsConfiguration = PickerTopViewButtonConfiguration(text: L10n.Buttons.done,
                                                                    activeColor: Color.TextField.Toolbar.buttonActive,
                                                                    highlightedColor: Color.TextField.Toolbar.buttonPressed)
        return PickerTopViewConfiguration(backgroundColor: Color.TextField.Toolbar.background,
                                          separatorsColor: Color.TextField.Toolbar.separator,
                                          button: buttonsConfiguration)
    }

}

...

field.inputView = DatePickerView.default(for: field)
````

* Само `view` клавиатуры создается точно таким же образом, что и раньше
* Переопределяется background для UIDatePicker
* Переопределяется стиль тулбара:
	* необходимо указать заголовок кнопки "Готово"
	* цвет кнопок тулбара в обычном и нажатом состояниях
	* цвет бэкграунда для тулбара
	* и цвет его сепараторов

В результате, DatePickerView может выглядеть следующим образом:

<p align="center">
	<img src="https://raw.githubusercontent.com/chausovSurfStudio/TextFieldsCatalog/master/tech_docs/Images/DatePickerViewCustomized.png" />
</p>

### PlainPickerView

<p align="center">
	<img src="https://raw.githubusercontent.com/chausovSurfStudio/TextFieldsCatalog/master/tech_docs/Images/PlainPickerView.png" />
</p>

Представляет собой обертку над самым обычным UIPickerView. Принцип работы и кастомизации аналогичен DatePickerView, потому в данной секции будут описаны только особенности PlainPickerView:

* При создании необходимо указать `[String]` - данные, которые будут отображаться в качестве вариантов выбора в барабане
* При изменении значения в барабане - новое значение будет автоматически подставляться в поле ввода
* Получить новое значение можно с помощью замыкания поля ввода 
	* `var onTextChanged: ((BorderedTextField) -> Void)?`

BestPractise по применению данного типа клавиатуры можно посмотреть в тестовом проекте.

### Переключение полей ввода

Зачастую в целях улучшения UX необходимо 'связать' между собой несколько полей ввода: чтобы пользователь использовал для переключения между ними одну лишь клавиатуру, не тапая непосредственно на сами поля.

Поля ввода из данной библиотеки имеют следующий метод:

````swift
func setNextResponder(_ nextResponder: UIResponder)
````
Он позволит поменять тип кнопки 'return' на `.next`, и при тапе на эту кнопку пользователь будет переключаться на переданное в качестве параметра поле ввода.

**Важный момент**: в качестве 'nextResponder' необходимо передавать не само поле ввода (это всего лишь обертка, UIView), а непосредственно сам UITextField (доступ напрямую закрыт, не забываем) - для этого определено такое свойство, как `responder`. В простейшем случае связка двух полей ввода выглядит следующим образом:

````swift
firstTextField.setNextResponder(secondTextField.responder)
````

Если речь заходит о кастомных клавиатурах, представленных в данной библиотеке - то в них присутствует тулбар с возможностью переключения между полями ввода. Для того, чтобы кнопки переключения появились в тулбаре и работали, необходимо установить `nextResponder`, о котором говорилось выше, а также `previousResponder` (метод для установки аналогичен предудыщему, только название другое). Кнопки переключения в тулбаре могут не быть, может быть только одна из двух, а могут быть обе вместе - все зависит от того, установите ли вы next/previous responder.

**Очень важно**: устанавливать next/previous responder необходимо до того, как вы создаете `DatePickerView`/`PlainPickerView` - потому что видимость кнопок переключения между полями в тулбаре задается в момент создания элемента, так что к этому времени next/previous responder должны быть установлены.

## Валидаторы

На поля ввода в реальном приложении могут накладываться различные ограничения: на минимальную/максимальную длину введенного текста, обязательность наличия текста в поле, соответствие его некоему регулярному выражению и прочее. Поля ввода в данной библиотеке поддерживают проверку на соответствие таким требованиям с помощью так называемых 'валидаторов'.

С одной стороны, соответствие того или иного текста неким бизнес требованиям должно проверяться на том слое приложения, где определена бизнес-логика, а не на view-слое. В целом, ничего не мешает вам при использовании полей ввода из данной библиотеки придерживаться данного правила - после сняти фокуса с поля ввода достаточно будет прокинуть введенный текст на бизнес-слой приложения, где он пройдет проверку, после чего, в случае ошибки, передать view сообщение о том, что определенное поле содержит ошибку. Методы для установки ошибки в поле ввода со стороны view имеются в наличии. С другой стороны - зачем так делать, когда имеется вполне удобный механизм?) А те или иные ограничения вполне можно передавать во view в качестве параметров.

### TextFieldValidation

Все поля данной библиотеки имеют так называемый 'валидатор':

````swift
var validator: TextFieldValidation?
````

Это объект, реализующий протокол `TextFieldValidation`, который содержит один единственный метод:

````swift
public protocol TextFieldValidation: class {
    func validate(_ text: String?) -> (isValid: Bool, errorMessage: String?)
}
````

Благодаря данному методу поле ввода в любой момент времени может передать валидатору текущее введенное значение и получить информацию о том корректно ли оно, а также текст ошибки, если значение не соответствует требованиям.

Данный метод будет вызываться:

* в случае вызова метода `func isValidState(forceValidate: Bool = false) -> Bool`
* в случае снятия фокуса с поля ввода
* в момент установки текста (метод `func setText(_ text: String?)`)

### TextFieldValidator

Вы можете определить свой валидатор со своей логикой, главное - чтобы он соответствовал протоколу `TextFieldValidation`. Но библиотека имеет уже готовый валидатор `TextFieldValidator`, покрывающий большинство кейсов, возникающих в приложениях.

Рассмотрим более подробно конструктор данного класса:

````swift
public init(minLength: Int?, 
            maxLength: Int?, 
            regex: String?, 
            globalErrorMessage: String? = nil, 
            requiredField: Bool = true)
````

При создании валидатора вы можете указать следующие параметры:

* `minLength` - минимальная длина строки в поле ввода
* `maxLength` - максимальная длина
* `regex` - регулярное выражение, которому должна соответствовать строка в поле ввода. При этом `public enum SharedRegex` содержит некоторые готовые регулярные выражения (к примеру, для проверки на правильность заполнения поля `Email`)
* `globalErrorMessage` - сообщение, которое будет показываться в случае возникновения любого типа ошибки
* `requiredField` - параметр позволяет управлять 'обязательностью' поля. К примеру, в случае если ваше поле может остаться не заполненным, но если пользователь его заполняет, то оно должно быть от 8 до 10 символов, то можно передать в качестве данного параметра `false`. Тогда, если пользователь оставит поле пустым, оно будет считаться корректно заполненным, но если он начнет его заполнять (введет 1 символ и более) - то введенное значение будет проверяться на соответствие всем остальным требованиям

В `TextFieldValidator` конструктивно присутствуют 4 вида ошибок (перечислены в порядке их проверки):

* поле не заполнено (возникает, когда `minLength` > 0, но поле ввода пустое)
* введенное значение меньше, чем минимально допустимая длина
* введенное значение превышает максимально допустимую длину
* значение не соответствует регулярному выражению

В случае возникновения любой из этих ошибок полю ввода будет передаваться соответствующий `errorMessage` - для каждый ошибки свое сообщение. Его можно сделать одинаковым с помощью параметра `globalErrorMessage`, указываемом при инициализации объекта. Но можно и переопределить сообщения для конкретных ошибок.

**Важно**: для ошибки, когда значение в поле ввода превышает максимальную длину, отсутствует текст ошибки по умолчанию в силу того, что есть возможность указать `maxLength` при настройке поля ввода - и пользователь физически не сможет ввести строку больше, чем это значение, соответственно и ошибка может возникнуть крайне редко.

### Локализация TextFieldValidator

Библиотека написана для широкого круга пользователей, потому тексты ошибок для стандартного валидатора локализуются под два языка.

Но в жизни не редки случаи, когда необходимо на девайсе с любым языком показывать тексты ошибок на одном определенном (случаи, когда приложение локализовано только под один язык). В этом случае - рекомендуется написать свою обертку над `TextFieldValidator`.

В процессе создания обертки - она будет создавать объект класса `TextFieldValidator`, сохранять его в качестве `private let`, и сразу же переопределять тексты ошибок. При вызове же метода из протокола `TextFieldValidation` - будет возвращаться ответ из сохраненного ранее стандартного валидатора. Таким образом, цель обертки - переопределить тексты ошибок во время инициализации.

## Форматтеры

Одна из самых приятных, но в то же время наименее стабильно работающая, фич полей ввода из данной библиотеки - наличие `MaskTextFieldFormatter`. Объект данного класса позволяет обеспечить ввод строки в поле ввода в соответствии с определенной маской: номера телефона, номера банковской карты, CVC-кода банковской карты и т.д.

Под капотом используется библиотека `InputMask`, потому рекомендуется сначала ознакомится с ее [документацией](https://github.com/RedMadRobot/input-mask-ios). В частности, с правилами создания масок.

Для присоединения форматтера к полю ввода необходимо написать следующий код:

````swift
textField.maskFormatter = MaskTextFieldFormatter(mask: FormatterMasks.phone)
````

При инициализации объекта класса `MaskTextFieldFormatter` необходимо указать только лишь маску, которой должна соответствовать строка в поле ввода. В качестве примера, в библиотеке реализовано несколько масок, которые можно найти в `public enum FormatterMasks`.

Помимо заранее определенных символов, допустимых к использованию при написании маски, можно задать свои: для этого необходимо определить так называемые 'нотации'. Каждая нотация содержит CharacterSet - набор допустимых символов, а также символ, которым этот набор будет обозначаться в маске. В качестве примера: рекомендую посмотреть `enum FormatterMasks` из проекта с полями ввода, а также его `extension` в тестовом проекте.

**Важно**: в силу использования сторонней библиотеки, баги данной библиотеки могут наложится на нее и усилить эффект. В частности, не всегда корректно работает вставка текста в поле, в котором определен форматтер (после вставки курсор может оказаться в неожиданном месте).

## Особенности UnderlinedTextView

Отдельным особняком в данном каталоге стоит такое поле, как `UnderlinedTextView`. На данный момент это пока единственная обертка над `UITextView`.

Область применения данного поля - какие-либо поля ввода, где ожидается большое количества текста, в силу чего пользователь должен видеть его полностью. Поле ввода расширяется вместе с возрастанием количества текста в нем.

В силу того, что под капотом используется UITextView, то кнопка 'return' клавиатуры не переопределяется, поведение остается неизменным - по тапу на нее курсор переносится на новую строку. В силу чего невозможно настроить переход на следующее поле ввода напрямую из клавиатуры, если оно имеется (отсутствует такой метод, как `setNextResponder`).

Отсутствует `formatter` за ненадобностью, но присутствует `validator`.

Поле ввода имеет дополнительную фичу - при наборе текста, если длина введенного значения больше 0, появляется кнопка очистки содержимого. Ее можно скрыть полностью с помощью такой переменной поля, как `hideClearButton`, по умолчанию установленной в `false`. Но если вы не собираетесь ее скрывать - пристуствует возможность кастомизации данной кнопки.

## Побочные фичи

При написании библиотеки часть внутренних классов, используемых в ней, показалась достаточно важной и функционально насыщенной, в силу чего было принято решение сделать их открытыми для стороннего использования.

### InnerTextField

Данный наследник `UITextField` используется во всех полях ввода, являющихся оберткой над `UITextField`.

Имеет некоторые интересные возможности, в частности:

* с помощью переменной `pasteActionEnabled` можно включить/выключить вставку текста в поле ввода
* с помощью переменных `textPadding`/`placeholderPadding` можно управлять отступами текста и плейсхолдера
* а метод `func fixCursorPosition()` позволяет поправить положение курсора таким образом, чтобы он стоял на нужной позиции (к примеру, позиция курсора может сбиться при переключении свойства `isSecureTextEntry`, тогда этот метод поможет вернуть курсор на место)
* параметр `resetSecureInput`. Рассмотрим следующий кейс: пользователь что-то ввел в поле ввода пароля, поле в `isSecureTextEntry` режиме, снял фокус, поставил фокус, продолжает вводить. По-умолчанию, когда `resetSecureInput` стоит в false - будет применяться логика, которая при продолжении ввода сохранит ранее введенное значение. Если же изменить его в true - то будет рпименяться дефолтное поведение системного поля ввода -> введенный ранее текст будет сбрасываться

### MaskTextFieldFormatter

Можно использовать форматтеры текстовых полей для форматирования текста. Для этого необходимо инициализировать объект класса `MaskTextFieldFormatter` и вызвать метод `format`.

Пример использования: 

```swift
let formatter = MaskTextFieldFormatter(mask: mask)
return formatter.format(string: text)
```

Данный код отвечает за преобразование строки к определенному виду в соответствие с маской. К примеру, у вас есть номер телефона "9129999999", тогда данный класс вместе с нужной маской вполне смогут привести его к виду "+7 (912) 999-99-99".

## Кастомизация

В следующем [документе](https://github.com/chausovSurfStudio/TextFieldsCatalog/blob/master/tech_docs/Configuration.md) вы можете найти подробную инструкцию о возможностях кастомизации полей ввода.

## Заметки разработчика

В данном [документе](https://github.com/chausovSurfStudio/TextFieldsCatalog/blob/master/tech_docs/DevNotes.md) собрана вспомогательная информация, полученная во время разработки - мысли, заметки, и тд. Все, что поможет в будущем понять тот или иной кусок логики.